### 本地变量

![image-20211102162801724](C:\Users\Ryz\AppData\Roaming\Typora\typora-user-images\image-20211102162801724.png)

> 主要注意的点就是，本地变量不能被隐式初始化，但实例字段可以（实例字段隐式初始化为:所有类型初始化为0，引用类型初始化为null，bool类型初始化为false）

### var 关键字

1. 只能用于本地变量。 2. 必须在本地变量有被初始化时使用 3. 一旦确定类型不会改变

> var不是一种特定类型变量的符号，只是一个语法上的速记，不像其他的弱类型语言，可以引用不同的类型。
>
> 所以var关键字并不改变C#强类型语言的性质



### 参数

> 值参数和引用参数  是指传参的方式，不能和 值类型和 引用类型混淆， 两个完全不是一种东西的东西。。。

#### 	值参数

 	直接上图好了，其中 a1为一个引用类型，a2为值类型。

#### 	![image-20211102184302206](C:\Users\Ryz\AppData\Roaming\Typora\typora-user-images\image-20211102184302206.png)

#### ref 引用参数

-  在方法的声明和调用时都需要加上 **ref**修饰符

- 实参必须是被赋值后的变量

![image-20211102184537428](C:\Users\Ryz\AppData\Roaming\Typora\typora-user-images\image-20211102184537428.png)

可以看到，引用参数和C++一样都相当于形参直接作为实参的**别名**了

> 对比这两种参数，值类型就没啥好说的了，但是 引用类型作为值参数和引用参数时，会出现的情况:
>
> ​		如果引用类型作为值参数，那么如果在方法内部形参引用了其他的对象，形参和实参之间的联系就断开了。
>
> ​		但引用类型如果作为引用参数的话，形参就相当于实参的别名（应该和C++一样，引用参数的 **形参** 存储的是 **引用类型实参本身的内存地址**，相对比值参数的 **形参**存储的是 **引用类型实参指向的内存地址**），所以形参引用新的对象，实参同样做出改变。

#### out 输出参数

基本上和 引用参数一样，包括

- 需要在 调用和声明方法时 都要加 修饰符 **out**
- 形参也相当于实参的别名；

除了这一点和引用参数不一样：

- 不能通过输出参数像方法传值，也就是说输出参数在**方法内部**被赋值之前，都不可以在方法中读取输出参数的值。而且本来就是输出参数，所以必须要在方法结束前对输出参数进行赋值。

#### 参数数组

- 一个参数列中只能有一个参数数组，并且还的是在最后一个参数。
- 声明方法时要加 修饰符 params，但调用时不用

调用含有参数数组的方法时有两种形式：

​	`void ListInts(params int[] inVals){}`

1. 调用时使用一些分离的实参

   ` ListInts(x1, x2, x3.....);`

2. 直接使用数组实参

   ````C#
   int[] myArr = new int[] {/*datas*/};
   ListInts(myArr);
   ````



### 方法的签名（signature）

只包括这两部分

 - 方法的名称
 - 参数列表

方法重载： 使用相同名称不同参数列表的方法



### 命名参数

方法的调用时可以直接通过相应  ***形参 : 实参***  就可以

```C#
void Calc(int a, int b, int c){codes}
//调用
Calc(a: 实参, b: argument, c: argument)
```

默认参数这些就不记了。。

