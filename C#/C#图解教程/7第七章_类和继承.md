> 先回顾一下C++里边的继承关系:（）
>
> 1. 首先要分清类内和类外的访问关系。对于父类的成员，不论是哪一种继承方式，在子类的内部 除父类的私有成员外的其他成员都可以访问。（虽然在内存上不是这样，但是可以当做子类并没有继承到父类的私有成员）
>
> 2. 接着就是分清楚 不同的继承方式改变的到底是什么： 不同的继承方式改变的就只是  **父类成员在子类中的类型** ：
>
>    公有继承：子类所继承的父类成员（前边已经说了父类的私有成员直接当做没继承到）不改变类型 
>
>    保护继承：子类所继承的父类成员全部改为保护类型
>
>    私有继承：子类所继承的父类成员全部变为私有类型



> > 感觉如果事无巨细的记简直就是和抄书一样，毕竟C#和C++相似的部分很多，就只记一些要点好了，需要记忆的点（ps：主要是不知道原理，不然是没有记忆的东西的我感觉）

---



### 类继承

​	可能是没有像C++那样的不同继承方式，只讲了`class MyDerived: MyBase`这样的语法，

> 在C#中，除了 object类以外，其他的所有类都是派生类。就算是自己新建的类也会隐式地继承object类。
>
> 1. 单继承：一个类声明的 *基类规格说明* 中只能有一个类。

![image-20211102153811358](C:\Users\Ryz\AppData\Roaming\Typora\typora-user-images\image-20211102153811358.png)

### new关键字

​	由于派生类会继承基类的成员，如果想要在派生类中使用基类的同名成员实现其他功能时，就可以在派生类定义一个与基类成员同名的成员来屏蔽基类的同名成员。

> 可以屏蔽 **静态成员**

### override(覆写)关键字

> 1. 不能override **静态方法**或者**非虚方法**， 属性、事件、和 索引器加了virtual 都可以在子类中override
> 2. 如果有多层继承的话，使用父类的引用去引用子类对象时，会持续找到最顶层的override方法调用。也就是说override和virtual是一组连接，只要上层还有override，那就会一直向上连接，直至最顶层的override方法。 如图：

![image-20211102154047763](C:\Users\Ryz\AppData\Roaming\Typora\typora-user-images\image-20211102154047763.png)

> mybc 为 一个基类的引用，有一个SecondDerived类的实例在堆内。则mybc调用Print方法时，就会调用SecondDerived类override的方法。

### 可访问性

#### 	类的可访问性	

​		类的可访问性只有两种： internal 和 public 	

​		internal 只能在该程序集下使用，而public就可以在其他程序集使用。

> 至于程序集是啥，这书后几章会讲。。

#### 	类成员的可访问性

​		类成员的可访问性不能超过类的可访问性，也就是说，如果类的访问性如果是internal的话，其成员的不论是那种可访问性都不可以超出该程序集。

​	例如，前提是 一个类为public，其成员分为如下几种可访问性：

>  由于C#纯面向对象编程，所以访问也就是指的哪些类可以访问，而所有的类也就这几种情况： 
>
>   1. 继承  2. 非继承  3. 在同一个程序集  4.不在同一个程序集
>
>      （众所周知，世界上所有的类要么是继承我这个类的要么不是。世界上所有的类要么跟我这个类是一个程序集要么不是）

  		1. public							所有（指不论是否继承该类，是否在同一个程序集内）的类均可以访问				
  		2. private                          只有在自己类的内部可以访问
  		3. protected                     所有继承该类的类可以访问（不在一个程序集也是可以继承的！！）
  		4. internal                         所有在同一个程序集的类可以访问
  		5. protected internal       取 protected和internal 的**并集**



### 构造函数的访问

​	子类的构造会默认调用父类的无参构造函数。也可以通过 **base**来指定调用父类的哪一个构造函数

​	`public DerivedClass(): base(/*"arguments"*/){/*codes*/}`

​	子类的构造函数也能通过**this**来调用其他的构造函数

​	`public DerivedClass(): this(/*arguments*/){/*codes*/}`

### sealed 密封类

sealed 关键字 

`public sealed class ClassName{/*codes*/}`

密封类不能作为其他类的基类（可以理解为叶子结点）

### abstract 抽象类

`public abstract class{\*codes*\}`

- 抽象类只能作为其他类的基类（如果继承抽象类也可以）,其他类继承抽象类来实现父类的抽象成员，也是通过***override*** 关键字

- 不能创建实例
- 可以包含抽象成员和非抽象成员
- 抽象类可以继承另一个抽象类

> 抽象成员只能是函数成员(也就是说 方法、属性、事件、索引)，而不能是字段和常量。
>
> 同时抽象成员也要加 abstract 关键字,且无代码块
>
> ```1C#
> public abstract class
> {
> 		public abstract void SomeMethod();
> 		public abstract string SomeProperty{get; set;}
> }
> ```
